<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Auditors Handbook to Nimbus Beacon Chain</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="01_introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="02_the_Nim_programming_language.html"><strong aria-hidden="true">2.</strong> The Nim Programming Language</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="02.1_nim_routines_proc_func_templates_macros.html"><strong aria-hidden="true">2.1.</strong> Nim routines, procedures, functions, templates, macros</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="02.1.1_operators_bit_manipulation.html"><strong aria-hidden="true">2.1.1.</strong> Operators, bit manipulation</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="02.2_stack_ref_ptr_types.html"><strong aria-hidden="true">3.</strong> Datatypes: value, ref, ptr</a></li><li class="chapter-item expanded "><a href="02.3_correctness_distinct_mutability_effects_exceptions.html"><strong aria-hidden="true">4.</strong> Correctness: distinct, mutability, effects, exceptions</a></li><li class="chapter-item expanded "><a href="02.4_debugging_Nim_sanitizers_fuzzers.html"><strong aria-hidden="true">5.</strong> Debugging Nim, sanitizers, fuzzers</a></li><li class="chapter-item expanded "><a href="02.5_foreign_lang_to_from_interop.html"><strong aria-hidden="true">6.</strong> Foreign lang interop: C and C++</a></li><li class="chapter-item expanded "><a href="02.8_Nim_threat_model.html"><strong aria-hidden="true">7.</strong> Nim threat model</a></li><li class="chapter-item expanded "><a href="02.10_Nim_FAQ.html"><strong aria-hidden="true">8.</strong> Nim FAQ</a></li><li class="chapter-item expanded "><a href="03_nbc_nimbus_beacon_chain.html"><strong aria-hidden="true">9.</strong> Nimbus NBC - The Nim-Beacon-Chain</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="03.2_build_system_and_dependencies.html"><strong aria-hidden="true">9.1.</strong> Build system and dependencies</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">The Auditors Handbook to Nimbus Beacon Chain</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>The Nimbus Nim-Beacon-Chain (NBC) project is an implementation of the <a href="https://github.com/ethereum/eth2.0-specs">Ethereum 2 Beacon Chain specification</a> in the <a href="https://nim-lang.org/">Nim programming language</a>.</p>
<p>The Auditors' Handbook aims to be provide a comprehensive introduction to:</p>
<ul>
<li>The Nim programming language, as used in the project.</li>
<li>The NBC project.</li>
<li>The dependencies of the project.</li>
</ul>
<p>A particular focus will be given to feature related to safety, correctness, error handling, testing, fuzzing, or inspecting Nim code.</p>
<p>One of the major highlight of Nim is that it compiles to C or C++ before compiling to native code. All techniques available to audit C code can be used to audit Nim.</p>
<h1><a class="header" href="#the-nim-programming-language" id="the-nim-programming-language">The Nim Programming Language</a></h1>
<p>The Nim programming language is a compiled language, with strong static typing.</p>
<p>The rest of the Handbook will assume that Nim-by-example was read.</p>
<p>Nim compilation process is in 2 phases, first lowering the Nim code to C, C++ or Javascript. Then for machine code, rely on the C/C++ compiler to produce the final code.</p>
<p>Nim can target any combination of C compiler, host OS and hardware architecture as long as the C compiler supports it.</p>
<h2><a class="header" href="#installing" id="installing">Installing</a></h2>
<p>Nim can be installed via:</p>
<ul>
<li>A Linux distribution package manager or Homebrew on MacOS</li>
<li>Instructions at https://nim-lang.org/install.html</li>
<li>Docker: https://hub.docker.com/r/nimlang/nim/</li>
<li>https://github.com/dom96/choosenim</li>
</ul>
<p>Nim Vagrant (https://github.com/status-im/nim-vagrant) is unmaintained but might
help setting up your own virtualized environment</p>
<p>We target Nim 1.2.2 and should be compatible with the latest stable, Nim 1.2.4</p>
<h2><a class="header" href="#casings" id="casings">Casings</a></h2>
<p>Nim has unusual partial case insensitivity for identifiers. The rationales being:</p>
<ul>
<li>Preventing bugs when using <code>SDL_QUIT</code> instead of <code>SDL_Quit</code>.</li>
<li>Having consistent casing in a codebase even when relying on external dependencies with different casing.</li>
</ul>
<p>The convention used in Nim-Beacon-Chain is:</p>
<ul>
<li><code>snake_case</code> for fields and procedures names from the Ethereum spec</li>
<li><code>MACRO_CASE</code> for Ethereum spec constants</li>
<li><code>PascalCase</code> for all types (Ethereum or additional)</li>
<li><code>camelCase</code> for our own additional code</li>
<li><code>PascalCase</code> for our additional constants</li>
</ul>
<p>In short, we respect the Ethereum spec for Ethereum specified identifiers
and use Nim NEP-1 for the rest</p>
<h2><a class="header" href="#checking-the-c-code" id="checking-the-c-code">Checking the C code</a></h2>
<p>By default the intermediate C code produced by the Nim compiler is available at</p>
<ul>
<li><code>$HOME/.nim/compiled_project_d</code> on UNIX systems</li>
<li><code>$HOME/nimcache/compiled_project_d</code> on Windows</li>
</ul>
<p>The suffix <code>_d</code> indicates a debug build, the suffix <code>_d</code> indicates a release build</p>
<h2><a class="header" href="#compiler-options" id="compiler-options">Compiler options</a></h2>
<p>At the time of writing, NBC targets Nim v1.2.2 compiler.
The build system is at https://github.com/status-im/nimbus-build-system.
No patching is done</p>
<p>Nim compiler offers debug, release with <code>-d:release</code> and danger with <code>-d:danger</code> flag.</p>
<p>The debug and <code>-d:release</code> build differ by, the verbosity of stacktraces and passing <code>-O3</code> or equivalent to the C compiler.</p>
<p>Runtime checks (overflow, array bounds checks, nil checks, ...) are still included in <code>-d:release</code> build. We also choose to have verbose stacktraces in NBC.</p>
<p>A danger build optimizes away all runtime checks and debugging help like stackframes. This might have a significant impact on performance
as it may enable optimizations that were not possible like optimizing tail calls. This is not used in NBC.</p>
<h2><a class="header" href="#references" id="references">References</a></h2>
<ul>
<li>
<p>Nim by example:</p>
<ul>
<li>https://nim-by-example.github.io/getting_started/</li>
</ul>
</li>
<li>
<p>The Nim Manual, is a specification of how Nim should behave<br />
https://nim-lang.org/docs/manual.html</p>
</li>
<li>
<p>Nim tutorials</p>
<ul>
<li>https://nim-lang.org/docs/tut1.html</li>
<li>https://nim-lang.org/docs/tut2.html</li>
<li>https://nim-lang.org/docs/tut3.html</li>
</ul>
</li>
<li>
<p>Nim for</p>
<ul>
<li>the C programmer: https://github.com/nim-lang/Nim/wiki/Nim-for-C-programmers</li>
<li>Python programmer: https://github.com/nim-lang/Nim/wiki/Nim-for-Python-Programmers</li>
</ul>
</li>
</ul>
<p>Further resources are collected at:</p>
<ul>
<li>https://nim-lang.org/learn.html</li>
</ul>
<h3><a class="header" href="#compiler-configuration" id="compiler-configuration">Compiler configuration</a></h3>
<ul>
<li>Compiler User Guide: https://nim-lang.org/docs/nimc.html</li>
</ul>
<h3><a class="header" href="#style-guide" id="style-guide">Style Guide</a></h3>
<ul>
<li>https://nim-lang.org/docs/nep1.html</li>
</ul>
<h1><a class="header" href="#nim-routines" id="nim-routines">Nim Routines</a></h1>
<p>Nim offers several kinds of &quot;routines&quot; that:</p>
<ul>
<li>do computation</li>
<li>produce side-effect</li>
<li>generate code</li>
</ul>
<p>Those are:</p>
<ul>
<li><code>proc</code> and <code>func</code></li>
<li><code>method</code></li>
<li><code>converter</code></li>
<li><code>iterator</code></li>
<li><code>template</code></li>
<li><code>macro</code></li>
</ul>
<h2><a class="header" href="#proc-and-func" id="proc-and-func"><code>proc</code> and <code>func</code></a></h2>
<p><code>proc</code> and <code>func</code> are the most basic routines.</p>
<p>At the moment, Nim requires forward declaration of proc and func.
Also it prevents circular dependencies, this means that a procedure is
always coming from one of the imports.</p>
<p>Additionally, all dependencies are submodules and a proc can be found by greping
<code>procname*</code>, the <code>*</code> being the export marker.</p>
<p>The only exception being the standard library. Procedures from the standard library are all listed in &quot;<a href="https://nim-lang.org/docs/theindex.html">The Index</a>&quot;.</p>
<h3><a class="header" href="#function-call-syntax" id="function-call-syntax">Function call syntax</a></h3>
<p>Nim provides flexible call syntax, the following are possible:</p>
<pre><code class="language-Nim">prof foo(a: int) =
  discard

foo(a)
foo a
a.foo()
a.foo
</code></pre>
<p>Additionally this is also possible for strings:</p>
<pre><code class="language-Nim">let a = fromHex&quot;0x12345&quot; # Without spaces
</code></pre>
<p>Nim doesn't enforce namespacing by default but is an option</p>
<pre><code class="language-Nim">let a = byteutils.fromhex&quot;0x12345&quot;
</code></pre>
<h3><a class="header" href="#parameters" id="parameters">Parameters</a></h3>
<p>Mutable parameters must be tagged with <code>var</code></p>
<p>TODO</p>
<h3><a class="header" href="#symbol-resolution" id="symbol-resolution">Symbol resolution</a></h3>
<p>If 2 procedures are visible in the same module (a module is a file) and
have the same name the compiler will infer which to call from the arguments
signatures. In case both are applicable, the compiler will throw an &quot;ambiguous call&quot; compile-time error.</p>
<p>Note that a procedure specialized to a concrete type has priority over a generic procedure, for example a procedure for int64 over a procedure for all number types.</p>
<h3><a class="header" href="#func-and-side-effect-analysis" id="func-and-side-effect-analysis"><code>func</code> and side effect analysis</a></h3>
<p>In Nim a proc is considered to have side-effect if it accesses a global variable.
Mutating a declared function parameter is not considered a side-effect as there is no access to a global variable.
Printing to the standard output or reading the standard input is considered a sideeffect.</p>
<p><code>func</code> are syntactic sugar for <code>proc</code> without sideeffects. In particular this means that <code>func</code> behaviors are fully determined by their input parameters.</p>
<p>In the codebase, logging at the <code>trace</code> level are not considered a sideeffect.</p>
<p>Additionally some logging statements and metrics statement may be in an explicit <code>{.noSideEffect.}:</code> code-block.</p>
<h3><a class="header" href="#returning-values" id="returning-values">Returning values</a></h3>
<p>There are 3 syntaxes to return a value from a procedure:</p>
<ol>
<li>The return statement</li>
<li>The implicit <code>result</code> variable</li>
<li>The &quot;last statement as expression&quot;</li>
</ol>
<pre><code class="language-Nim">proc add1(x: int): int =
  return x + 1

proc add2(x: int): int =
  result = x + 2

proc add3(x: int): int =
  x + 3
</code></pre>
<p>The main differences are:</p>
<ol>
<li><code>return</code> allows early returns, in particular from a loop.</li>
<li><code>result</code> offers Return Value Optimization and Copy Elision
which is particularly valuable for array types.</li>
<li>Requires the last statement to be a valid expression.
This is particularly interesting for conditional return values
as forgetting to set the value in a branch will be a compile-time error,
for example:
<pre><code class="language-Nim">proc select(ctl: bool, a, b: int): int =
  if ctl:
    echo &quot;heavy processing&quot;
    a
  else:
    echo &quot;heavy processing&quot;
    b
</code></pre>
Omitting <code>a</code> or <code>b</code> will be a compiletime error, unlike
<pre><code class="language-Nim">proc select(ctl: bool, a, b: int): int =
  if ctl:
    echo &quot;heavy processing&quot;
    return a
  else:
    echo &quot;heavy processing&quot;
    # Forgot to return b
</code></pre>
<pre><code class="language-Nim">proc select(ctl: bool, a, b: int): int =
  if ctl:
    echo &quot;heavy processing&quot;
    result = a
  else:
    echo &quot;heavy processing&quot;
    # Forgot to result = b
</code></pre>
</li>
</ol>
<p>Due to the differences we prefer using the &quot;last statement as expression&quot; unless</p>
<ul>
<li>copying the type is expensive (SHA256 hash for example)</li>
<li>or we need early returns</li>
</ul>
<h4><a class="header" href="#ignoring-return-values" id="ignoring-return-values">Ignoring return values</a></h4>
<p>Unlike C, return values MUST be used or explicitly discarded.</p>
<h4><a class="header" href="#mutable-return-values" id="mutable-return-values">Mutable return values</a></h4>
<p>TODO</p>
<h3><a class="header" href="#at-a-low-level" id="at-a-low-level">At a low-level</a></h3>
<h4><a class="header" href="#argument-passing" id="argument-passing">Argument passing</a></h4>
<p>Nim passes arguments by value if they take less than 3*sizeof(pointer) (i.e. 24 bytes on 64-bit OS) and passes them by pointer with the C backend or reference with the C++ backend if they are bigger.
Mutable arguments are always passed by pointer.</p>
<p>This behavior can be changed on a type-by-type bases by tagging them {.bycopy.} or {.byref.}. This is only used for interfacing with non-Nim code.</p>
<h4><a class="header" href="#stacktraces" id="stacktraces">Stacktraces</a></h4>
<p>With <code>--stacktrace:on</code>, Nim create a stackframe on <code>proc</code> entry and destroys it on exit. This is used for reporting stacktraces.</p>
<p>NBC is always compiled with <code>--stacktraces:on</code></p>
<p>NBC uses <a href="https://github.com/ianlancetaylor/libbacktrace">libbacktrace</a> to have less costly stacktraces.</p>
<h4><a class="header" href="#name-in-the-c-code-or-assembly" id="name-in-the-c-code-or-assembly">Name in the C code or Assembly</a></h4>
<p><code>proc</code> and <code>func</code> are materialized in the produced C code with name-mangling appended at the end. For the purpose of building Nim libraries, the name can be controlled by:</p>
<ul>
<li><code>{.exportc.}</code> so that the generated C name is the same as Nim</li>
<li>`{.exportc: &quot;specific_name&quot;.} to generate a specific name</li>
</ul>
<h2><a class="header" href="#method" id="method"><code>method</code></a></h2>
<p><code>method</code>s are used for dynamic dispatch when an object has an inherited subtype only known at runtime.</p>
<p><code>method</code> are dispatched using a dispatch tree in the C code instead of a VTable.</p>
<p>There might be some cases where <code>method</code> were used not for their intended purpose</p>
<h2><a class="header" href="#converter" id="converter"><code>converter</code></a></h2>
<p>Converters are procedures that are implicitly called on a value to change its type.</p>
<p>For example with a fictional option type that automatically extracts the boxed type.</p>
<pre><code class="language-Nim">type Option[T] = object
  case hasValue: bool
  of true:
    value: T
  else:
    discard

converter get[T](x: Option[T]): T =
  x.value

let x = Option[int](hasValue: true, value: 1)
let y = Option[int](hasValue: true, value: 2)

let z = x + y
</code></pre>
<p>Even though the <code>+</code> operator is not defined for <code>Option[int]</code> it is defined for <code>int</code> and Nim implicitly calls the converter.</p>
<p><code>converter</code> are seldom used in the codebase as we prefer explicit over implicit.</p>
<p>Note that in case an operation is defined on both the convertible and the converted type, the operation without conversion should be preferred however <a href="https://github.com/nim-lang/Nim/issues/7416">the compiler might throw an ambiguous call instead</a>.</p>
<h2><a class="header" href="#iterators" id="iterators">Iterators</a></h2>
<p>Iterators are construct that transforms a for loop.</p>
<p>For example to iterate on a custom array collection</p>
<pre><code class="language-Nim">const MaxSize = 7

type SmallVec[T] = object
    buffer*: array[MaxSize, T]
    len*: int

iterator items*[T](a: SmallVec[T]): T =
  for i in 0 ..&lt; a.len:
    yield a.data[i]
</code></pre>
<p>Now iterating becomes</p>
<pre><code class="language-Nim">for value in a.items():
  echo a
</code></pre>
<p>A singly-linked list forward iterator could be implemented as</p>
<pre><code class="language-Nim">iterator items[T](head: ref T): ref T =
  ## Singly-linked list iterator
  assert: not head.isNil
  var cur = head
  while true:
    let next = cur.next
    yield cur
    cur = next
    if cur.isNil:
      break
</code></pre>
<p>a doubly-linked list backward iterator as</p>
<pre><code class="language-Nim">iterator backward[T](tail: ptr T): ptr T =
  var cur = tail
  while not cur.isNil:
    let prev = cur.prev
    yield cur
    cur = prev
</code></pre>
<p>an iterator to unpack individual bits from a byte as:</p>
<pre><code class="language-Nim">iterator unpack(scalarByte: byte): bool =
  yield bool((scalarByte and 0b10000000) shr 7)
  yield bool((scalarByte and 0b01000000) shr 6)
  yield bool((scalarByte and 0b00100000) shr 5)
  yield bool((scalarByte and 0b00010000) shr 4)
  yield bool((scalarByte and 0b00001000) shr 3)
  yield bool((scalarByte and 0b00000100) shr 2)
  yield bool((scalarByte and 0b00000010) shr 1)
  yield bool( scalarByte and 0b00000001)
</code></pre>
<p>In all cases, the syntax to iterate on the collection remains:</p>
<pre><code class="language-Nim">for value in a.items():
  echo a

for value in b.backward():
  echo b

for bit in s.unpack():
  echo s
</code></pre>
<p>The echo is inlined at &quot;yield&quot;.</p>
<p>Iterators are not present in the produced C code, they are always inlined at the callsite.</p>
<p>Iterators are prone to code bloat, for example</p>
<pre><code class="language-Nim">iterator iterate[T](s: seq[T], backward: bool): T =
  if backward:
    for i in s.len-1 .. 0:
      yield s[i]
  else:
    for i in 0 ..&lt; s.len:
      yield s[i]

for value in s.iterate(backward = false):
  ## Long-series of operations
  echo value
</code></pre>
<p>The long series of operation will be duplicated.</p>
<h3><a class="header" href="#items-and-pairs" id="items-and-pairs"><code>items</code> and <code>pairs</code></a></h3>
<p>The <code>items</code> and <code>pairs</code> iterator are special cased and implictly call
if there is respectively one and two iteration variables hence:</p>
<pre><code class="language-Nim">for x in collection:
  echo x
</code></pre>
<p>will automatically call the <code>items</code> proc defined for the collection (or error)</p>
<pre><code class="language-Nim">for x, y in collection:
  echo x
  echo y
</code></pre>
<p>will automatically call the <code>pairs</code> proc defined for the collection (or error)</p>
<h3><a class="header" href="#fields-and-fieldpairs" id="fields-and-fieldpairs"><code>fields</code> and <code>fieldPairs</code></a></h3>
<p><code>fields</code> and <code>fieldsPairs</code> are iterator-like magic, that allow &quot;iterating&quot; on an object field. Note that those are unrolled at compile-time.</p>
<h2><a class="header" href="#closures-and-closure-iterators" id="closures-and-closure-iterators">Closures and closure iterators</a></h2>
<p>Will be covered in a dedicated section.</p>
<p>They are the backbone of Chronos, our async/await framework and also
have a major potential for memory leaks.</p>
<h2><a class="header" href="#template" id="template"><code>template</code></a></h2>
<p><code>template</code>s in Nim allows raw code substitution.</p>
<p><code>templates</code> are hygienic and typechecked unlike the C preprocessor.
Also they create their own scope unless tagged with the <code>{.dirty.}</code> pragma.</p>
<p>A major issue with templates is that as they &quot;copy-paste&quot; code, it is very easy to misuse them and do a computation twice.</p>
<p>For instance</p>
<pre><code class="language-Nim">proc foo(): int =
  echo &quot;launch missile&quot;
  return 1

template doSomething(a: int) =
  process(a)
  log(a)
</code></pre>
<p>This would be transformed to:</p>
<pre><code class="language-Nim">process(foo())
log(foo())
</code></pre>
<p>and triggers the &quot;launch missile&quot; side-effect twice.</p>
<p>Another issue with templates is that they may not generate stacktraces properly as
they are not materialized in the C code.</p>
<h3><a class="header" href="#symbol-visibility-and-inject" id="symbol-visibility-and-inject">Symbol visibility and {.inject.}</a></h3>
<p>TODO</p>
<h2><a class="header" href="#macro" id="macro"><code>macro</code></a></h2>
<p>TODO</p>
<h2><a class="header" href="#the-do-notation" id="the-do-notation">The <code>do</code> notation</a></h2>
<p>TODO</p>
<h1><a class="header" href="#operators-and-bit-manipulation" id="operators-and-bit-manipulation">Operators and bit manipulation</a></h1>
<h2><a class="header" href="#operators" id="operators">Operators</a></h2>
<p>A set of symbol and keywords can be used as infix operators
Nim supports operator overloading.</p>
<p>Those symbols are:</p>
<pre><code>=     +     -     *     /     &lt;     &gt;
@     $     ~     &amp;     %     |
!     ?     ^     .     :     \
</code></pre>
<p>The keyword operators are</p>
<pre><code>and or not xor shl shr div mod in notin is isnot of as
</code></pre>
<p>In-particular:</p>
<ul>
<li>bitwise and, or, flip, xor are denoted <code>and</code>, <code>or</code>, <code>not</code>, <code>xor</code> instead of using a symbol</li>
<li>shift left and right are <code>shl</code> and <code>shr</code></li>
<li>division and modulo are <code>div</code> and <code>mod</code></li>
</ul>
<h3><a class="header" href="#implementation-defined-behaviors" id="implementation-defined-behaviors">Implementation-defined behaviors</a></h3>
<p><code>mod</code> is defined as the mathematical remainder, like C. With signed integers <code>a mod b</code> has the same sign as <code>a</code></p>
<p><code>shr</code> of a signed integer will not preserve the sign bit.
<code>ashr</code> can be used for arithmetic right shift.</p>
<p>This distinction was introduced recently and may lead to subtle bugs,
also <code>ashr</code> relies on the C compiler actually lowering <code>&gt;&gt;</code> to SAR for signed integer.
This is specified for GCC and Clang (https://gcc.gnu.org/onlinedocs/gcc/Integers-implementation.html#Integers-implementation)
but implementation defined in general.</p>
<h3><a class="header" href="#operator-precedence" id="operator-precedence">Operator precedence</a></h3>
<p>Operator precedence is specified described in the manual:</p>
<p>https://nim-lang.org/docs/manual.html#syntax-precedence</p>
<h3><a class="header" href="#additional-system-operators" id="additional-system-operators">Additional system operators</a></h3>
<p>Nim system exports additional operators with a <code>%</code> like <code>+%</code> and <code>-%</code>.
Those cast the signed integer operand to unsigned and cast the result back to signed.
This is intended to use with the ByteAddress type for pointer arithmetic</p>
<h2><a class="header" href="#bit-manipulation" id="bit-manipulation">Bit manipulation</a></h2>
<p>https://github.com/status-im/nim-stew/blob/master/stew/bitops2.nim</p>
<h1><a class="header" href="#nim-data-types" id="nim-data-types">Nim data types</a></h1>
<h2><a class="header" href="#builtin-types" id="builtin-types">Builtin types</a></h2>
<h3><a class="header" href="#numerical-types" id="numerical-types">Numerical types</a></h3>
<p>For integers, Nim offers <code>uint8</code>, <code>uint16</code>, <code>uint32</code> and <code>uint64</code> types as well as <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code> types.</p>
<p>Operations on signed integers are overflowed and underflowed checked unless the flag <code>--overflowChecks:off</code> is used.</p>
<p>Nim also offers <code>int</code> and <code>uint</code> types, which have the same size as the platform word size, so 4 bytes when compiled for 32-bit OS
or 8 bytes for a 64-bit OS.</p>
<p>Conversion between <code>int</code> and <code>int32</code> or <code>int64</code> must be explicit except for string literals.</p>
<p>Integer literals default to <code>int</code>.</p>
<p><code>float32</code> and <code>float64</code> maps to C <code>float</code> and <code>double</code>. <code>float</code> is an alias to <code>float64</code> whether on a 32-bit or 64-bit platform</p>
<h4><a class="header" href="#binary-blobs" id="binary-blobs">Binary blobs</a></h4>
<p>Nim has a specific <code>byte</code> type which behaves like uint8.</p>
<p>It is the preferred type to represent binary blobs, i.e. we use <code>seq[byte]</code> over <code>string</code>, <code>seq[char]</code> or <code>seq[uint8]</code> for binary data.</p>
<h4><a class="header" href="#range-types" id="range-types">Range types</a></h4>
<p>Nim allows defining ranges of valid value which will be runtime checked everytime the value changes for example
Nim defines by default <code>type Natural = range[0 .. high(int)]</code>. If the value of a Natural becomes less than 0
an RangeError exception will be thrown.</p>
<p>This is valuable to catch / prevent underflows.</p>
<h2><a class="header" href="#sequences" id="sequences">Sequences</a></h2>
<p>Sequences are heap-allocated containers similar to C++ vectors.</p>
<p>They have value-semantics and are copied on assignments.</p>
<p>Sequences have a data pointer, reserved memory and current length</p>
<h2><a class="header" href="#strings" id="strings">Strings</a></h2>
<p>Sequences are heap-allocated containers.</p>
<p>They have value-semantics and are copied on assignments.</p>
<p>Strings have a data pointer, reserved memory and current length.</p>
<p>The data is terminated by <code>\0</code>.</p>
<p>Nim strings automatically decays without copy to C strings in FFI calls</p>
<p>The representation is the same as a <code>seq[byte]</code> or <code>seq[char]</code> except for the terminating nul-byte,
including within the GC tracking data structures
Consequently, strings can be cast to <code>seq[byte]</code> but inversely casting <code>seq[byte]</code> to string
will lead to non nul-terminated string in C FFI and buffer overflows.</p>
<h2><a class="header" href="#record--structs" id="record--structs">Record / structs</a></h2>
<p>Nim has 3 kinds of record types</p>
<ul>
<li>
<p>Value</p>
<pre><code class="language-Nim">type Foo = object
  field0: int
  field1: float
</code></pre>
</li>
<li>
<p>Reference</p>
<pre><code class="language-Nim">type Foo = ref object
  field0: int
  field1: float
</code></pre>
</li>
<li>
<p>Pointer</p>
<pre><code class="language-Nim">type Foo = ptr object
  field0: int
  field1: float
</code></pre>
</li>
</ul>
<h3><a class="header" href="#value" id="value">Value</a></h3>
<p>A value object is allocated on the stack (unless if nested in heap-allocated types).</p>
<p>The equality check is structural.</p>
<p>Copy is done by copyMem (C memcpy)</p>
<p>Object variants do not have an equality operator set by default</p>
<h3><a class="header" href="#reference" id="reference">Reference</a></h3>
<p>A reference object is allocated on the heap and managed by the GC.</p>
<p>They are not thread-safe.</p>
<p>The equality check is by reference</p>
<p>Copy is done by copying the reference and increment the reference count</p>
<h3><a class="header" href="#pointer" id="pointer">Pointer</a></h3>
<p>A pointer object is manually managed, it can be on the heap (malloc) or on the stack (alloca)</p>
<h1><a class="header" href="#correctness-distinct-mutability-effects-exceptions" id="correctness-distinct-mutability-effects-exceptions">Correctness, distinct, mutability, effects, exceptions</a></h1>
<p>The Nim compiler provides several constraints that can be used to enforce
proper usage of variables, types and error handling at compile-time.</p>
<p>One was already mentioned in previous paragraphs:</p>
<ul>
<li>Side-Effect analysis via using <code>func</code> or <code>{.noSideEffect.}</code> (in the routines chapter)</li>
</ul>
<p><em>Note that range types currently work at runtime only</em></p>
<h2><a class="header" href="#side-effect" id="side-effect">Side-Effect</a></h2>
<p>As mentioned in the routines chapter, using a <code>func</code> or a proc tagged with <code>{.noSideEffect.}</code> will prevent reading or writing to global variables (i.e. variables that are neither parameters or locals).</p>
<p>Note that side-effect analysis cannot analyse raw emitted C code</p>
<p>Additionally, allocating a sequence or a string, even if they technically
access a global memory allocator, is not considered a side-effect.</p>
<p>The compiler will ignore statements in a <code>{.noSIdeEffect.}</code> block for the purpose of side-effect analysis. At the moment this is only used for trace and some debug logs, as writing to stdout/stderr is considered writing to a global variables and so a side-effect.</p>
<h2><a class="header" href="#not-nil" id="not-nil"><code>not nil</code></a></h2>
<p>The compiler exposes a &quot;not nil&quot; annotation for reference and pointer types.
This enforces that parameters are proven always initialized in tagged:</p>
<ul>
<li>procedures</li>
<li>types</li>
</ul>
<p>This is not used in the codebase as a more powerful prover is required for our application.</p>
<p>Currently, the compiler warns when it cannot prove that a result reference is not nil.</p>
<h2><a class="header" href="#distinct-types" id="distinct-types"><code>distinct</code> types</a></h2>
<p>A distinct type is a type that has the same representation as a base type at a low-level but cannot be used in its stead.</p>
<pre><code class="language-Nim">type Miles = distinct float32
type Meters = distinct float32
</code></pre>
<p>Procedures accepting:</p>
<ul>
<li><code>float32</code> will not accept <code>Miles</code> or <code>Meters</code></li>
<li><code>Miles</code> will not accept <code>float32</code> or <code>Meters</code></li>
<li><code>Meters</code> will not accept <code>float32</code> or <code>Miles</code></li>
</ul>
<p><code>distinct</code> type can reuse the base type procedures and fields via the borrow annotation as described in the manual https://nim-lang.org/docs/manual.html#types-distinct-type</p>
<h2><a class="header" href="#enforcing-exception-handling" id="enforcing-exception-handling">Enforcing exception handling</a></h2>
<p>The codebase uses a mix of Result and Exceptions for error handling
with option types and bool in some cases.</p>
<p>As an effort to sanitize error handling and ensure that all exception paths are handled, we use the effect tracking system the following way:</p>
<pre><code class="language-Nim">proc foo() {.raises: [].} =
  discard
</code></pre>
<p>The procedure above will refuse to compile if its body can throw an unhandled exception.</p>
<pre><code class="language-Nim">proc foo() {.raises: [ValueError].} =
  discard
</code></pre>
<p>The procedure above will refuse to compile if its body can throw an exception besides a ValueError.</p>
<p>In particular Nim distinguishes between Defects, which are non-recoverable, and Exceptions, which we should recover from.</p>
<p>For our purposes, we allow all procedures to throw a Defect (for example an assertion broken), this is done by adding <code>{.push raises:[Defect]}</code> at the start of a file</p>
<pre><code class="language-Nim">{.push raises:[Defect]}

proc foo1() =
  discard

proc foo2() =
  discard

{.pop.}
</code></pre>
<h2><a class="header" href="#mutability" id="mutability">Mutability</a></h2>
<p>Only variables declared with <code>var</code> and <code>var</code> parameters are mutable.</p>
<p>Note that mutability analysis is not deep for reference types or pointer types.
You can always mutate through a pointer.</p>
<h2><a class="header" href="#future" id="future">Future</a></h2>
<p>Significant improvements are in-progress planned to improve Nim safety:</p>
<ul>
<li><code>lent</code> return values and owned reference, a limited form of borrow checker: https://nim-lang.org/docs/destructors.html#lent-type</li>
<li>Z3 theorem prover for bound checks and nil checks at compile-time: https://nim-lang.org/docs/drnim.html</li>
<li>write-tracking to prevent deep immutability: https://github.com/nim-lang/RFCs/issues/234 (https://nim-lang.org/araq/writetracking.html)</li>
</ul>
<p>however it is too early to use them</p>
<h1><a class="header" href="#debugging-nim" id="debugging-nim">Debugging Nim</a></h1>
<p>Reference article: https://nim-lang.org/blog/2017/10/02/documenting-profiling-and-debugging-nim-code.html</p>
<h2><a class="header" href="#gdb--lldb" id="gdb--lldb">GDB / LLDB</a></h2>
<p>Nim can be instrumented with sourcemaps:</p>
<ul>
<li>by passing <code>--debugger:native</code> to the compiler, so that the stacktraces in gdb shows the Nim source code</li>
<li>by passing <code>--passC:&quot;-g&quot;</code> to the compiler, so that the stacktraces in gdb shows the C source code</li>
</ul>
<h2><a class="header" href="#sanitizers--valgrind" id="sanitizers--valgrind">Sanitizers &amp; Valgrind</a></h2>
<p>LLVM and GCC sanitizers can be used with</p>
<pre><code class="language-Nim">nim c --cc:clang -r -d:release --debugger:native \
  --passC:&quot;-fsanitize=address&quot; --passL:&quot;-fsanitize=address&quot; \
  --outdir:build target_application.nim
</code></pre>
<p>Note on deactivating Nim memory allocator:</p>
<p>As mentioned in the memory management section, Nim has</p>
<ul>
<li>a garbage collector, by default deferred reference counting + cycle detection via mark-and-sweep if the types can have cycles (and is not tagged {.acyclic.})</li>
<li>an allocator based on TLSF</li>
</ul>
<p>Instead of Nim custom allocators, the sys malloc/free can be used by passing
<code>-d:useMalloc</code> in the command-line</p>
<p><em>Some GC/versions might not properly accept the flag, this is a Nim bug and we can patch upstream and our own fork in that case</em></p>
<h2><a class="header" href="#fuzzers" id="fuzzers">Fuzzers</a></h2>
<p>TODO</p>
<h3><a class="header" href="#internal-fuzzing" id="internal-fuzzing">Internal fuzzing</a></h3>
<p>We are currently adding fuzzing to our repositories via libFuzzer and AFL.</p>
<ul>
<li>Fuzzing abstraction: https://github.com/status-im/nim-testutils</li>
<li>Network lib fuzzing: https://github.com/status-im/nim-eth/tree/4f533eb5/tests/fuzzing</li>
<li>Eth2 core/Validator core fuzzing: https://github.com/status-im/nim-blscurve/tree/271a5738/tests/fuzzing</li>
</ul>
<h3><a class="header" href="#external-consensus-fuzzing" id="external-consensus-fuzzing">External &quot;Consensus&quot; fuzzing</a></h3>
<p>Sigma Prima is fuzzing all Ethereum 2 clients on the spec (Eth2 core/Validator core)</p>
<p>We provide them with a simple C API</p>
<ul>
<li>https://github.com/status-im/nim-beacon-chain/blob/4a2e1806/nfuzz/libnfuzz.h</li>
</ul>
<p>That we implement:</p>
<ul>
<li>https://github.com/status-im/nim-beacon-chain/blob/4a2e1806/nfuzz/libnfuzz.nim</li>
</ul>
<p>And compile the nim code as a shared or static library.</p>
<p>On usage, the only extra limitation compared to a C library is the need to call <code>NimMain()</code> before calling any Nim function to initialize the Nim runtime.</p>
<h2><a class="header" href="#inspecting-the-generated-intermediate-code-and-objects" id="inspecting-the-generated-intermediate-code-and-objects">Inspecting the generated intermediate code and objects</a></h2>
<p>The intermediate C code and object files are stored in</p>
<ul>
<li><code>$HOME/.cache/nim/compiled_target_d</code> or <code>$HOME/.cache/nim/compiled_target_r</code> on UNIX (d for debug, r for release)</li>
<li><code>$HOME/nimcache/compiled_target_d</code> or <code>$HOME/.cache/nim/compiled_target_r</code> on Windows</li>
</ul>
<p>The cache directory can be set with the <code>--nimcache=&lt;targetdir&gt;</code> compiler flag.</p>
<p>Repositories vendoring <code>nimbus-build-system</code> do not use the default setting
but generate directly in the (gitignored) <code>nimcache</code> folder of the repo.</p>
<h1><a class="header" href="#foreign-language-interop" id="foreign-language-interop">Foreign language interop</a></h1>
<h2><a class="header" href="#wrapping-c" id="wrapping-c">Wrapping C</a></h2>
<h3><a class="header" href="#using-shared-library" id="using-shared-library">Using shared library</a></h3>
<p>Example: secp256k1</p>
<p>https://github.com/status-im/nim-secp256k1/blob/master/secp256k1_abi.nim</p>
<h3><a class="header" href="#compiling-directly-the-c-files" id="compiling-directly-the-c-files">Compiling directly the C files</a></h3>
<p>Example: Apache Milagro Crypto</p>
<p>https://github.com/status-im/nim-blscurve/blob/master/blscurve/milagro.nim</p>
<h2><a class="header" href="#wrapping-c-1" id="wrapping-c-1">Wrapping C++</a></h2>
<p>Beyond the syntax for wrapping C, Nim offers a flexible syntax for wrapping C++,
for example for vectors:</p>
<pre><code class="language-Nim">type
  CppVector* {.importcpp&quot;std::vector&quot;, header: &quot;&lt;vector&gt;&quot;, byref.} [T] = object

proc newCppVector*[T](): CppVector[T] {.importcpp: &quot;std::vector&lt;'*0&gt;()&quot;, header: &quot;&lt;vector&gt;&quot;, constructor.}
proc newCppVector*[T](size: int): CppVector[T] {.importcpp: &quot;std::vector&lt;'*0&gt;(#)&quot;, header: &quot;&lt;vector&gt;&quot;, constructor.}
proc len*(v: CppVector): int {.importcpp: &quot;#.size()&quot;, header: &quot;&lt;vector&gt;&quot;.}
proc add*[T](v: var CppVector[T], elem: T){.importcpp: &quot;#.push_back(#)&quot;, header: &quot;&lt;vector&gt;&quot;.}
proc `[]`*[T](v: CppVector[T], idx: int): T{.importcpp: &quot;#[#]&quot;, header: &quot;&lt;vector&gt;&quot;.}
proc `[]`*[T](v: var CppVector[T], idx: int): var T{.importcpp: &quot;#[#]&quot;, header: &quot;&lt;vector&gt;&quot;.}
proc `[]=`*[T](v: var CppVector[T], idx: int, value: T) {.importcpp: &quot;#[#]=#&quot;, header: &quot;&lt;vector&gt;&quot;.}
</code></pre>
<p>Example: ttmath</p>
<p>https://github.com/status-im/nim-ttmath/blob/master/src/ttmath.nim</p>
<h2><a class="header" href="#exporting" id="exporting">Exporting</a></h2>
<p>See &quot;Fuzzing&quot; chapter for exporting a C API for fuzzing</p>
<h2><a class="header" href="#references-1" id="references-1">References</a></h2>
<ul>
<li>Nim manual:
<ul>
<li>https://nim-lang.org/docs/manual.html#foreign-function-interface-importc-pragma</li>
<li>https://nim-lang.org/docs/manual.html#implementation-specific-pragmas-importcpp-pragma</li>
</ul>
</li>
<li>Nim backend integration: https://nim-lang.org/docs/backends.html</li>
</ul>
<h1><a class="header" href="#nim-threat-model" id="nim-threat-model">Nim threat model</a></h1>
<p>Nim and its standard library are not the focus of the audits.</p>
<p>In particular the codebase intentionally limits reliance on the standard library
so that it is not tied to Nim release schedule, instead of the standard library
we use <code>stew</code> most of the time: https://github.com/status-im/nim-stew.</p>
<p>Nim standard library is implemented here:</p>
<ul>
<li>https://github.com/nim-lang/Nim/tree/v1.2.4/lib</li>
</ul>
<p>We target Nim v1.2.2</p>
<h1><a class="header" href="#nim-faq" id="nim-faq">Nim FAQ</a></h1>
<h1><a class="header" href="#nimbus-beacon-chain" id="nimbus-beacon-chain">Nimbus Beacon Chain</a></h1>
<p>https://github.com/status-im/nim-beacon-chain</p>
<p>Nimbus Beacon Chain (NBC) is an implementation of an Ethereum 2 client.</p>
<h2><a class="header" href="#audit-scope" id="audit-scope">Audit scope</a></h2>
<h3><a class="header" href="#network-core-leveraging-the-libp2p-framework" id="network-core-leveraging-the-libp2p-framework">Network Core (leveraging the libp2p framework)</a></h3>
<table><thead><tr><th>Sub-topic</th></tr></thead><tbody>
<tr><td>Discovery Protocol (discv5)</td></tr>
<tr><td>Publish/Subscribe protocol</td></tr>
<tr><td>Eth2 Request/Response protocol</td></tr>
<tr><td>SSZ - (De)serialization &amp; tree hashing</td></tr>
<tr><td>Wire encryption</td></tr>
</tbody></table>
<h3><a class="header" href="#eth2-specification-core" id="eth2-specification-core">ETH2 Specification core</a></h3>
<table><thead><tr><th>Sub-topic</th></tr></thead><tbody>
<tr><td>State transition logic</td></tr>
<tr><td>Signature verification</td></tr>
<tr><td>Epoch finalisation and justification</td></tr>
<tr><td>Reward processing</td></tr>
<tr><td>Eth1 data processing</td></tr>
<tr><td>Fork choice logic</td></tr>
<tr><td>Block processing and production</td></tr>
<tr><td>Attestation processing and production</td></tr>
<tr><td>Block synchronization</td></tr>
<tr><td>Peer pool management</td></tr>
</tbody></table>
<h3><a class="header" href="#validator-core-and-user-experience" id="validator-core-and-user-experience">Validator core and user experience</a></h3>
<table><thead><tr><th>Sub-topic</th></tr></thead><tbody>
<tr><td>Block/attestation signing</td></tr>
<tr><td>Slash-prevention mechanisms</td></tr>
<tr><td>RPC API</td></tr>
<tr><td>Accounts management &amp; key storage</td></tr>
<tr><td>Command Line Interface (CLI)</td></tr>
</tbody></table>
<h2><a class="header" href="#high-level-view-of-the-stack" id="high-level-view-of-the-stack">High-level view of the stack</a></h2>
<p>https://miro.com/app/board/o9J_kvfytDI=/</p>
<h2><a class="header" href="#diagram" id="diagram">Diagram</a></h2>
<p>TODO</p>
<h2><a class="header" href="#specifications" id="specifications">Specifications</a></h2>
<p>We target v0.12.1 phase0 of https://github.com/ethereum/eth2.0-specs</p>
<ul>
<li>https://github.com/ethereum/eth2.0-specs/tree/v0.12.1/specs/phase0</li>
</ul>
<p>The p2p-interface specs in particular describe the subset of libp2p spec that
are used to implement Ethereum 2</p>
<h1><a class="header" href="#nimbus-build-system--dependencies" id="nimbus-build-system--dependencies">Nimbus build system &amp; dependencies</a></h1>
<h2><a class="header" href="#build-system" id="build-system">Build system</a></h2>
<h3><a class="header" href="#nbc-repo" id="nbc-repo">NBC repo</a></h3>
<p><code>nim-beacon-chain</code> uses a build system based on makefiles.
Usage is described in the README.</p>
<p>In particular a <code>env.sh</code> scripts is provided that setups the environment variable
expected.</p>
<h3><a class="header" href="#libraries" id="libraries">Libraries</a></h3>
<p>Library repositories uses the official package manager called <code>nimble</code>
for building and testing.</p>
<p>In particular, we use by convention the following command to run the test suite via nimble task system:</p>
<pre><code class="language-Nim">nimble test
</code></pre>
<p>The details are implemented in <code>&lt;package name&gt;.nimble</code> at the root of the repository.</p>
<p>The continuous integration setup for Travis, Azure Pipelines and/or Appveyor
are also setting up a Nim environment from scratch.</p>
<h2><a class="header" href="#package-dependencies" id="package-dependencies">Package dependencies</a></h2>
<h3><a class="header" href="#nbc-repo-1" id="nbc-repo-1">NBC repo</a></h3>
<p>For the <code>nim-beacon-chain</code> application, all dependencies are vendored
in the <code>vendor</code> folder.</p>
<p>With regards to the audit scope we have the following dependencies:</p>
<h4><a class="header" href="#all" id="all">All</a></h4>
<ul>
<li>Async
<ul>
<li>asynctools</li>
<li>nim-chronos</li>
</ul>
</li>
<li>Logging
<ul>
<li>jswebsockets</li>
<li>karax</li>
<li>nim-chronicles</li>
<li>nim-chronicles-tail (devtool, out-of-audit-scope)</li>
<li>nim-libbacktrace</li>
<li>websocket.nim</li>
</ul>
</li>
<li>CLI interface
<ul>
<li>nim-confutils</li>
<li>nim-prompt</li>
<li>nim-unicodedb</li>
</ul>
</li>
<li>Metrics
<ul>
<li>nim-metrics (the server endpoint is out-of-audit-scope)</li>
</ul>
</li>
<li>Helpers
<ul>
<li>nim-stew</li>
<li>nim-testutils (fuzzing)</li>
<li>nimYAML (should be test only)</li>
</ul>
</li>
</ul>
<h4><a class="header" href="#network-core" id="network-core">Network core</a></h4>
<ul>
<li>Cryptography
<ul>
<li>nim-bearssl</li>
<li>nim-secp256k1</li>
<li>nimcrypto</li>
</ul>
</li>
<li>Networking &amp; Discovery
<ul>
<li>nim-eth</li>
<li>nim-libp2p</li>
<li>nim-nat-traversal</li>
</ul>
</li>
<li>Serialization
<ul>
<li>nim-faststreams</li>
<li>nim-protobuf-serialization (unused ?)</li>
<li>nim-serialization</li>
<li>nim-snappy</li>
</ul>
</li>
<li>BigInt
<ul>
<li>nim-stint (Note: one of the main use is 256-bit bloomfilter, a dedicated library should be used instead)</li>
</ul>
</li>
</ul>
<h4><a class="header" href="#eth2-specification-core-1" id="eth2-specification-core-1">ETH2 Specification core</a></h4>
<ul>
<li>Cryptography
<ul>
<li>nim-blscurve</li>
</ul>
</li>
<li>Database
<ul>
<li>nim-rocksdb</li>
<li>nim-sqlite3-abi</li>
</ul>
</li>
<li>Eth1 monitoring
<ul>
<li>nim-web3</li>
</ul>
</li>
<li>Build system
<ul>
<li>nimbus-build-system</li>
</ul>
</li>
</ul>
<h4><a class="header" href="#validator-core" id="validator-core">Validator core</a></h4>
<ul>
<li>Cryptography
<ul>
<li>nim-blscurve</li>
</ul>
</li>
<li>RPC
<ul>
<li>news</li>
<li>nim-http-utils</li>
<li>nim-json-rpc</li>
<li>nim-json-serialization</li>
</ul>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
